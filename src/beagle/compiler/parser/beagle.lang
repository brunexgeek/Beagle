/**
 *
 * Copyright (C) 1996, 1997 Sun Microsystems Inc.
 *
 * Use of this file and the system it is part of is constrained by the
 * file COPYRIGHT in the root directory of this system.  You may, however,
 * make any modifications you wish to this file.
 *
 * Java files generated by running JavaCC on this file (or modified versions
 * of this file) may be used in exactly the same manner as Java files
 * generated from any grammar developed by you.
 *
 * Author: Sriram Sankar
 * Date: 3/5/97
 *
 * This file contains a Java grammar and actions that implement a front-end.
 *
 */

options
{
    STATIC=false;
    JAVA_UNICODE_ESCAPE=true;
}

PARSER_BEGIN(BeagleParser)

package beagle.compiler.parser;

import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;

import beagle.compiler.ast.*;
import beagle.compiler.ast.body.*;
import beagle.compiler.ast.expression.*;
import beagle.compiler.ast.type.*;
import beagle.compiler.ast.statement.*;

public class BeagleParser extends AbstractParser
{

}

PARSER_END(BeagleParser)

TOKEN_MGR_DECLS :
{
    int indent = 0;
    int level = 0;
    int parens = 0;
    int indentation[] = new int[20];


    public final void indenting(int ind) {
        indent = ind;
        if (indent == indentation[level])
            SwitchTo(INDENTATION_UNCHANGED);
        else
            SwitchTo(INDENTING);
    }

}

SKIP :
{
    " "
|   "\r"
|   "\t"
| <NEWLINE1 : ("\r\n" | "\r" | "\n" ) >
    {
        if (parens == 0) {
            indent = 0;
            input_stream.backup(1);
            if (level == 0)
                SwitchTo(FORCE_NEWLINE1);
            else
                SwitchTo(FORCE_NEWLINE2);
        }
    }
}


/*
 * Keywords.
 */


TOKEN :
{
      < IN: "in" >
    | < IF: "if" >
    | < DO: "do" >

    | < FOR: "for" >
    | < TRY: "try" >
    | < NEW:  "new" >

    | < PASS: "pass" >
    | < ENUM: "enum" >
    | < ELIF: "elif" >
    | < CASE: "case" >
    | < ELSE: "else" >
    | < TRUE: "true" >
    | < NULL: "null" >
    | < THIS: "this" >

    | < FALSE: "false" >
    | < FINAL: "final" >  // Modifier
    | < CONST: "const" >  // Modifier
    | < SUPER: "super" >
    | < WHILE: "while" >
    | < CATCH: "catch" >
    | < BREAK: "break" >
    | < THROW: "throw" >
    | < CLASS: "class" >

    | < IMPORT: "import" >
    | < STATIC: "static" >  // Modifier
    | < PUBLIC: "public" >  // Modifier
    | < NATIVE: "native" >  // Modifier
    | < EXPORT: "export" >  // Modifier
    | < SWITCH: "switch" >
    | < RETURN: "return" >
    | < ASSERT: "assert" >

    | < FINALLY:  "finally" >
    | < PACKAGE:  "package" >
    | < PRIVATE:  "private" >
    | < EXTENDS:  "extends" >
    | < _DEFAULT: "default" >

    | < ABSTRACT: "abstract" >  // Modifier
    | < READLOCK: "readlock" >  // Modifier
    | < INTERNAL: "internal" >  // Modifier
    | < CONTINUE: "continue" >

    | < WRITELOCK: "writelock" >  // Modifier
    | < PROTECTED: "protected" >  // Modifier
    | < INTERFACE: "interface" >

    | < INSTANCEOF: "instanceof" >
    | < IMPLEMENTS: "implements" >

    | < SYNCHRONIZED: "synchronized" >  // Modifier
}


/*
 * Separators and special symbols.
 */


TOKEN :
{
      < LPAREN:    "(" >
    | < RPAREN:    ")" >
    | < LBRACE:    "{" >
    | < RBRACE:    "}" >
    | < LBRACKET:  "[" >
    | < RBRACKET:  "]" >
    | < SEMICOLON: ";" >
    | < COMMA:     "," >
    | < DOT:       "." >
    | < AT:        "@" >
}


/*
 * Math and logical operators.
 */


TOKEN :
{
      < ASSIGN: "=" >
    | < MUL:    "*" >
    | < DIV:    "/" >
    | < BAND:   "&" >
    | < BOR:    "|" >
    | < XOR:    "^" >
    | < REM:    "%" >
    | < LT:     "<" >
    | < GT:     ">" >
    | < BNEG:   "~" >
    | < HOOK:   "?" >
    | < COLON:  ":" >
    | < ADD:    "+" >
    | < SUB:    "-" >

    | < EQ:        "==" >
    | < LE:        "<=" >
    | < GE:        ">=" >
    | < NE:        "!=" >
    | < LOR:       "or" >
    | < INCR:      "++" >
    | < DECR:      "--" >
    | < SHL:    "<<" >
    | < SHR:    ">>" >
    | < ASN_ADD:  "+=" >
    | < ASN_SUB: "-=" >
    | < ASN_MUL:  "*=" >
    | < ASN_DIV: "/=" >
    | < ASN_BAND:  "&=" >
    | < ASN_BOR:   "|=" >
    | < ASN_XOR:   "^=" >
    | < ASN_REM:   "%=" >
    | < VARARG:    "...">

    | < LAND:    "and" >
    | < LNEG:    "not" >
    | < ASN_SHL: "<<=" >
    | < ASN_SHR: ">>=" >
}


/*
 * Primitive types.
 */

TOKEN :
{
      <VOID: "void">
    | <CHAR: "char">
    | <BYTE: "byte">
    | <SHORT: "short">
    | <INT: "int">
    | <LONG: "long">
    | <FLOAT: "float">
    | <FIXED: "fixed">
    | <DOUBLE: "double">
    | <BOOLEAN: "boolean">
}


/*
 * String and numeric literals. This rules was based in "javaparser" by JÃºlio Gesser
 */

TOKEN :
{
  < LONG_LITERAL:
        <DECIMAL_LITERAL> (["L"])
      | <HEX_LITERAL> (["L"])
      | <OCTAL_LITERAL> (["L"])
  >
|
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        <DECIMAL_FLOATING_POINT_LITERAL>
      | <HEXADECIMAL_FLOATING_POINT_LITERAL>
  >
|
  < #DECIMAL_FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["F","D"])?
      | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["F","D"])?
      | (["0"-"9"])+ <DECIMAL_EXPONENT> (["F","D"])?
      | (["0"-"9"])+ (<DECIMAL_EXPONENT>)? ["F","D"]
  >
|
  < #DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < #HEXADECIMAL_FLOATING_POINT_LITERAL:
        "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (["F","D"])?
      | "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (["F","D"])?
  >
|
  < #HEXADECIMAL_EXPONENT: ["P"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
        | ("\\u"
            ["0"-"9","A"-"F","a"-"f"]
            ["0"-"9","A"-"F","a"-"f"]
            ["0"-"9","A"-"F","a"-"f"]
            ["0"-"9","A"-"F","a"-"f"]
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
        | ("\\u"
            ["0"-"9","A"-"F","a"-"f"]
            ["0"-"9","A"-"F","a"-"f"]
            ["0"-"9","A"-"F","a"-"f"]
            ["0"-"9","A"-"F","a"-"f"]
          )
      )*
      "\""
  >
}


/*
 * Identifiers.
 */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<PART_LETTER>)* >
|
  < #LETTER: [
         "\u0024",          // "$"
         "\u0041"-"\u005a", // "A"-"Z"
         "\u005f",          // "_"
         "\u0061"-"\u007a", // "a"-"z"
         "\u00a2"-"\u00a5",
         "\u00aa",
         "\u00b5",
         "\u00ba",
         "\u00c0"-"\u00d6",
         "\u00d8"-"\u00f6",
         "\u00f8"-"\u0236",
         "\u0250"-"\u02c1",
         "\u02c6"-"\u02d1",
         "\u02e0"-"\u02e4",
         "\u02ee",
         "\u037a",
         "\u0386",
         "\u0388"-"\u038a",
         "\u038c",
         "\u038e"-"\u03a1",
         "\u03a3"-"\u03ce",
         "\u03d0"-"\u03f5",
         "\u03f7"-"\u03fb",
         "\u0400"-"\u0481",
         "\u048a"-"\u04ce",
         "\u04d0"-"\u04f5",
         "\u04f8"-"\u04f9",
         "\u0500"-"\u050f",
         "\u0531"-"\u0556",
         "\u0559",
         "\u0561"-"\u0587",
         "\u05d0"-"\u05ea",
         "\u05f0"-"\u05f2",
         "\u0621"-"\u063a",
         "\u0640"-"\u064a",
         "\u066e"-"\u066f",
         "\u0671"-"\u06d3",
         "\u06d5",
         "\u06e5"-"\u06e6",
         "\u06ee"-"\u06ef",
         "\u06fa"-"\u06fc",
         "\u06ff",
         "\u0710",
         "\u0712"-"\u072f",
         "\u074d"-"\u074f",
         "\u0780"-"\u07a5",
         "\u07b1",
         "\u0904"-"\u0939",
         "\u093d",
         "\u0950",
         "\u0958"-"\u0961",
         "\u0985"-"\u098c",
         "\u098f"-"\u0990",
         "\u0993"-"\u09a8",
         "\u09aa"-"\u09b0",
         "\u09b2",
         "\u09b6"-"\u09b9",
         "\u09bd",
         "\u09dc"-"\u09dd",
         "\u09df"-"\u09e1",
         "\u09f0"-"\u09f3",
         "\u0a05"-"\u0a0a",
         "\u0a0f"-"\u0a10",
         "\u0a13"-"\u0a28",
         "\u0a2a"-"\u0a30",
         "\u0a32"-"\u0a33",
         "\u0a35"-"\u0a36",
         "\u0a38"-"\u0a39",
         "\u0a59"-"\u0a5c",
         "\u0a5e",
         "\u0a72"-"\u0a74",
         "\u0a85"-"\u0a8d",
         "\u0a8f"-"\u0a91",
         "\u0a93"-"\u0aa8",
         "\u0aaa"-"\u0ab0",
         "\u0ab2"-"\u0ab3",
         "\u0ab5"-"\u0ab9",
         "\u0abd",
         "\u0ad0",
         "\u0ae0"-"\u0ae1",
         "\u0af1",
         "\u0b05"-"\u0b0c",
         "\u0b0f"-"\u0b10",
         "\u0b13"-"\u0b28",
         "\u0b2a"-"\u0b30",
         "\u0b32"-"\u0b33",
         "\u0b35"-"\u0b39",
         "\u0b3d",
         "\u0b5c"-"\u0b5d",
         "\u0b5f"-"\u0b61",
         "\u0b71",
         "\u0b83",
         "\u0b85"-"\u0b8a",
         "\u0b8e"-"\u0b90",
         "\u0b92"-"\u0b95",
         "\u0b99"-"\u0b9a",
         "\u0b9c",
         "\u0b9e"-"\u0b9f",
         "\u0ba3"-"\u0ba4",
         "\u0ba8"-"\u0baa",
         "\u0bae"-"\u0bb5",
         "\u0bb7"-"\u0bb9",
         "\u0bf9",
         "\u0c05"-"\u0c0c",
         "\u0c0e"-"\u0c10",
         "\u0c12"-"\u0c28",
         "\u0c2a"-"\u0c33",
         "\u0c35"-"\u0c39",
         "\u0c60"-"\u0c61",
         "\u0c85"-"\u0c8c",
         "\u0c8e"-"\u0c90",
         "\u0c92"-"\u0ca8",
         "\u0caa"-"\u0cb3",
         "\u0cb5"-"\u0cb9",
         "\u0cbd",
         "\u0cde",
         "\u0ce0"-"\u0ce1",
         "\u0d05"-"\u0d0c",
         "\u0d0e"-"\u0d10",
         "\u0d12"-"\u0d28",
         "\u0d2a"-"\u0d39",
         "\u0d60"-"\u0d61",
         "\u0d85"-"\u0d96",
         "\u0d9a"-"\u0db1",
         "\u0db3"-"\u0dbb",
         "\u0dbd",
         "\u0dc0"-"\u0dc6",
         "\u0e01"-"\u0e30",
         "\u0e32"-"\u0e33",
         "\u0e3f"-"\u0e46",
         "\u0e81"-"\u0e82",
         "\u0e84",
         "\u0e87"-"\u0e88",
         "\u0e8a",
         "\u0e8d",
         "\u0e94"-"\u0e97",
         "\u0e99"-"\u0e9f",
         "\u0ea1"-"\u0ea3",
         "\u0ea5",
         "\u0ea7",
         "\u0eaa"-"\u0eab",
         "\u0ead"-"\u0eb0",
         "\u0eb2"-"\u0eb3",
         "\u0ebd",
         "\u0ec0"-"\u0ec4",
         "\u0ec6",
         "\u0edc"-"\u0edd",
         "\u0f00",
         "\u0f40"-"\u0f47",
         "\u0f49"-"\u0f6a",
         "\u0f88"-"\u0f8b",
         "\u1000"-"\u1021",
         "\u1023"-"\u1027",
         "\u1029"-"\u102a",
         "\u1050"-"\u1055",
         "\u10a0"-"\u10c5",
         "\u10d0"-"\u10f8",
         "\u1100"-"\u1159",
         "\u115f"-"\u11a2",
         "\u11a8"-"\u11f9",
         "\u1200"-"\u1206",
         "\u1208"-"\u1246",
         "\u1248",
         "\u124a"-"\u124d",
         "\u1250"-"\u1256",
         "\u1258",
         "\u125a"-"\u125d",
         "\u1260"-"\u1286",
         "\u1288",
         "\u128a"-"\u128d",
         "\u1290"-"\u12ae",
         "\u12b0",
         "\u12b2"-"\u12b5",
         "\u12b8"-"\u12be",
         "\u12c0",
         "\u12c2"-"\u12c5",
         "\u12c8"-"\u12ce",
         "\u12d0"-"\u12d6",
         "\u12d8"-"\u12ee",
         "\u12f0"-"\u130e",
         "\u1310",
         "\u1312"-"\u1315",
         "\u1318"-"\u131e",
         "\u1320"-"\u1346",
         "\u1348"-"\u135a",
         "\u13a0"-"\u13f4",
         "\u1401"-"\u166c",
         "\u166f"-"\u1676",
         "\u1681"-"\u169a",
         "\u16a0"-"\u16ea",
         "\u16ee"-"\u16f0",
         "\u1700"-"\u170c",
         "\u170e"-"\u1711",
         "\u1720"-"\u1731",
         "\u1740"-"\u1751",
         "\u1760"-"\u176c",
         "\u176e"-"\u1770",
         "\u1780"-"\u17b3",
         "\u17d7",
         "\u17db"-"\u17dc",
         "\u1820"-"\u1877",
         "\u1880"-"\u18a8",
         "\u1900"-"\u191c",
         "\u1950"-"\u196d",
         "\u1970"-"\u1974",
         "\u1d00"-"\u1d6b",
         "\u1e00"-"\u1e9b",
         "\u1ea0"-"\u1ef9",
         "\u1f00"-"\u1f15",
         "\u1f18"-"\u1f1d",
         "\u1f20"-"\u1f45",
         "\u1f48"-"\u1f4d",
         "\u1f50"-"\u1f57",
         "\u1f59",
         "\u1f5b",
         "\u1f5d",
         "\u1f5f"-"\u1f7d",
         "\u1f80"-"\u1fb4",
         "\u1fb6"-"\u1fbc",
         "\u1fbe",
         "\u1fc2"-"\u1fc4",
         "\u1fc6"-"\u1fcc",
         "\u1fd0"-"\u1fd3",
         "\u1fd6"-"\u1fdb",
         "\u1fe0"-"\u1fec",
         "\u1ff2"-"\u1ff4",
         "\u1ff6"-"\u1ffc",
         "\u203f"-"\u2040",
         "\u2054",
         "\u2071",
         "\u207f",
         "\u20a0"-"\u20b1",
         "\u2102",
         "\u2107",
         "\u210a"-"\u2113",
         "\u2115",
         "\u2119"-"\u211d",
         "\u2124",
         "\u2126",
         "\u2128",
         "\u212a"-"\u212d",
         "\u212f"-"\u2131",
         "\u2133"-"\u2139",
         "\u213d"-"\u213f",
         "\u2145"-"\u2149",
         "\u2160"-"\u2183",
         "\u3005"-"\u3007",
         "\u3021"-"\u3029",
         "\u3031"-"\u3035",
         "\u3038"-"\u303c",
         "\u3041"-"\u3096",
         "\u309d"-"\u309f",
         "\u30a1"-"\u30ff",
         "\u3105"-"\u312c",
         "\u3131"-"\u318e",
         "\u31a0"-"\u31b7",
         "\u31f0"-"\u31ff",
         "\u3400"-"\u4db5",
         "\u4e00"-"\u9fa5",
         "\ua000"-"\ua48c",
         "\uac00"-"\ud7a3",
         "\ud801", //for supplementary characters suport
         "\ud802", //for supplementary characters suport
         "\uf900"-"\ufa2d",
         "\ufa30"-"\ufa6a",
         "\ufb00"-"\ufb06",
         "\ufb13"-"\ufb17",
         "\ufb1d",
         "\ufb1f"-"\ufb28",
         "\ufb2a"-"\ufb36",
         "\ufb38"-"\ufb3c",
         "\ufb3e",
         "\ufb40"-"\ufb41",
         "\ufb43"-"\ufb44",
         "\ufb46"-"\ufbb1",
         "\ufbd3"-"\ufd3d",
         "\ufd50"-"\ufd8f",
         "\ufd92"-"\ufdc7",
         "\ufdf0"-"\ufdfc",
         "\ufe33"-"\ufe34",
         "\ufe4d"-"\ufe4f",
         "\ufe69",
         "\ufe70"-"\ufe74",
         "\ufe76"-"\ufefc",
         "\uff04",
         "\uff21"-"\uff3a",
         "\uff3f",
         "\uff41"-"\uff5a",
         "\uff65"-"\uffbe",
         "\uffc2"-"\uffc7",
         "\uffca"-"\uffcf",
         "\uffd2"-"\uffd7",
         "\uffda"-"\uffdc",
         "\uffe0"-"\uffe1",
         "\uffe5"-"\uffe6"
      ]
  >
|
  < #PART_LETTER:
      [
         "\u0000"-"\u0008",
         "\u000e"-"\u001b",
         "\u0024",          // "$"
         "\u0030"-"\u0039", // "0"-"9"
         "\u0041"-"\u005a", // "A"-"Z"
         "\u005f",          // "_"
         "\u0061"-"\u007a", // "a"-"z"
         "\u007f"-"\u009f",
         "\u00a2"-"\u00a5",
         "\u00aa",
         "\u00ad",
         "\u00b5",
         "\u00ba",
         "\u00c0"-"\u00d6",
         "\u00d8"-"\u00f6",
         "\u00f8"-"\u0236",
         "\u0250"-"\u02c1",
         "\u02c6"-"\u02d1",
         "\u02e0"-"\u02e4",
         "\u02ee",
         "\u0300"-"\u0357",
         "\u035d"-"\u036f",
         "\u037a",
         "\u0386",
         "\u0388"-"\u038a",
         "\u038c",
         "\u038e"-"\u03a1",
         "\u03a3"-"\u03ce",
         "\u03d0"-"\u03f5",
         "\u03f7"-"\u03fb",
         "\u0400"-"\u0481",
         "\u0483"-"\u0486",
         "\u048a"-"\u04ce",
         "\u04d0"-"\u04f5",
         "\u04f8"-"\u04f9",
         "\u0500"-"\u050f",
         "\u0531"-"\u0556",
         "\u0559",
         "\u0561"-"\u0587",
         "\u0591"-"\u05a1",
         "\u05a3"-"\u05b9",
         "\u05bb"-"\u05bd",
         "\u05bf",
         "\u05c1"-"\u05c2",
         "\u05c4",
         "\u05d0"-"\u05ea",
         "\u05f0"-"\u05f2",
         "\u0600"-"\u0603",
         "\u0610"-"\u0615",
         "\u0621"-"\u063a",
         "\u0640"-"\u0658",
         "\u0660"-"\u0669",
         "\u066e"-"\u06d3",
         "\u06d5"-"\u06dd",
         "\u06df"-"\u06e8",
         "\u06ea"-"\u06fc",
         "\u06ff",
         "\u070f"-"\u074a",
         "\u074d"-"\u074f",
         "\u0780"-"\u07b1",
         "\u0901"-"\u0939",
         "\u093c"-"\u094d",
         "\u0950"-"\u0954",
         "\u0958"-"\u0963",
         "\u0966"-"\u096f",
         "\u0981"-"\u0983",
         "\u0985"-"\u098c",
         "\u098f"-"\u0990",
         "\u0993"-"\u09a8",
         "\u09aa"-"\u09b0",
         "\u09b2",
         "\u09b6"-"\u09b9",
         "\u09bc"-"\u09c4",
         "\u09c7"-"\u09c8",
         "\u09cb"-"\u09cd",
         "\u09d7",
         "\u09dc"-"\u09dd",
         "\u09df"-"\u09e3",
         "\u09e6"-"\u09f3",
         "\u0a01"-"\u0a03",
         "\u0a05"-"\u0a0a",
         "\u0a0f"-"\u0a10",
         "\u0a13"-"\u0a28",
         "\u0a2a"-"\u0a30",
         "\u0a32"-"\u0a33",
         "\u0a35"-"\u0a36",
         "\u0a38"-"\u0a39",
         "\u0a3c",
         "\u0a3e"-"\u0a42",
         "\u0a47"-"\u0a48",
         "\u0a4b"-"\u0a4d",
         "\u0a59"-"\u0a5c",
         "\u0a5e",
         "\u0a66"-"\u0a74",
         "\u0a81"-"\u0a83",
         "\u0a85"-"\u0a8d",
         "\u0a8f"-"\u0a91",
         "\u0a93"-"\u0aa8",
         "\u0aaa"-"\u0ab0",
         "\u0ab2"-"\u0ab3",
         "\u0ab5"-"\u0ab9",
         "\u0abc"-"\u0ac5",
         "\u0ac7"-"\u0ac9",
         "\u0acb"-"\u0acd",
         "\u0ad0",
         "\u0ae0"-"\u0ae3",
         "\u0ae6"-"\u0aef",
         "\u0af1",
         "\u0b01"-"\u0b03",
         "\u0b05"-"\u0b0c",
         "\u0b0f"-"\u0b10",
         "\u0b13"-"\u0b28",
         "\u0b2a"-"\u0b30",
         "\u0b32"-"\u0b33",
         "\u0b35"-"\u0b39",
         "\u0b3c"-"\u0b43",
         "\u0b47"-"\u0b48",
         "\u0b4b"-"\u0b4d",
         "\u0b56"-"\u0b57",
         "\u0b5c"-"\u0b5d",
         "\u0b5f"-"\u0b61",
         "\u0b66"-"\u0b6f",
         "\u0b71",
         "\u0b82"-"\u0b83",
         "\u0b85"-"\u0b8a",
         "\u0b8e"-"\u0b90",
         "\u0b92"-"\u0b95",
         "\u0b99"-"\u0b9a",
         "\u0b9c",
         "\u0b9e"-"\u0b9f",
         "\u0ba3"-"\u0ba4",
         "\u0ba8"-"\u0baa",
         "\u0bae"-"\u0bb5",
         "\u0bb7"-"\u0bb9",
         "\u0bbe"-"\u0bc2",
         "\u0bc6"-"\u0bc8",
         "\u0bca"-"\u0bcd",
         "\u0bd7",
         "\u0be7"-"\u0bef",
         "\u0bf9",
         "\u0c01"-"\u0c03",
         "\u0c05"-"\u0c0c",
         "\u0c0e"-"\u0c10",
         "\u0c12"-"\u0c28",
         "\u0c2a"-"\u0c33",
         "\u0c35"-"\u0c39",
         "\u0c3e"-"\u0c44",
         "\u0c46"-"\u0c48",
         "\u0c4a"-"\u0c4d",
         "\u0c55"-"\u0c56",
         "\u0c60"-"\u0c61",
         "\u0c66"-"\u0c6f",
         "\u0c82"-"\u0c83",
         "\u0c85"-"\u0c8c",
         "\u0c8e"-"\u0c90",
         "\u0c92"-"\u0ca8",
         "\u0caa"-"\u0cb3",
         "\u0cb5"-"\u0cb9",
         "\u0cbc"-"\u0cc4",
         "\u0cc6"-"\u0cc8",
         "\u0cca"-"\u0ccd",
         "\u0cd5"-"\u0cd6",
         "\u0cde",
         "\u0ce0"-"\u0ce1",
         "\u0ce6"-"\u0cef",
         "\u0d02"-"\u0d03",
         "\u0d05"-"\u0d0c",
         "\u0d0e"-"\u0d10",
         "\u0d12"-"\u0d28",
         "\u0d2a"-"\u0d39",
         "\u0d3e"-"\u0d43",
         "\u0d46"-"\u0d48",
         "\u0d4a"-"\u0d4d",
         "\u0d57",
         "\u0d60"-"\u0d61",
         "\u0d66"-"\u0d6f",
         "\u0d82"-"\u0d83",
         "\u0d85"-"\u0d96",
         "\u0d9a"-"\u0db1",
         "\u0db3"-"\u0dbb",
         "\u0dbd",
         "\u0dc0"-"\u0dc6",
         "\u0dca",
         "\u0dcf"-"\u0dd4",
         "\u0dd6",
         "\u0dd8"-"\u0ddf",
         "\u0df2"-"\u0df3",
         "\u0e01"-"\u0e3a",
         "\u0e3f"-"\u0e4e",
         "\u0e50"-"\u0e59",
         "\u0e81"-"\u0e82",
         "\u0e84",
         "\u0e87"-"\u0e88",
         "\u0e8a",
         "\u0e8d",
         "\u0e94"-"\u0e97",
         "\u0e99"-"\u0e9f",
         "\u0ea1"-"\u0ea3",
         "\u0ea5",
         "\u0ea7",
         "\u0eaa"-"\u0eab",
         "\u0ead"-"\u0eb9",
         "\u0ebb"-"\u0ebd",
         "\u0ec0"-"\u0ec4",
         "\u0ec6",
         "\u0ec8"-"\u0ecd",
         "\u0ed0"-"\u0ed9",
         "\u0edc"-"\u0edd",
         "\u0f00",
         "\u0f18"-"\u0f19",
         "\u0f20"-"\u0f29",
         "\u0f35",
         "\u0f37",
         "\u0f39",
         "\u0f3e"-"\u0f47",
         "\u0f49"-"\u0f6a",
         "\u0f71"-"\u0f84",
         "\u0f86"-"\u0f8b",
         "\u0f90"-"\u0f97",
         "\u0f99"-"\u0fbc",
         "\u0fc6",
         "\u1000"-"\u1021",
         "\u1023"-"\u1027",
         "\u1029"-"\u102a",
         "\u102c"-"\u1032",
         "\u1036"-"\u1039",
         "\u1040"-"\u1049",
         "\u1050"-"\u1059",
         "\u10a0"-"\u10c5",
         "\u10d0"-"\u10f8",
         "\u1100"-"\u1159",
         "\u115f"-"\u11a2",
         "\u11a8"-"\u11f9",
         "\u1200"-"\u1206",
         "\u1208"-"\u1246",
         "\u1248",
         "\u124a"-"\u124d",
         "\u1250"-"\u1256",
         "\u1258",
         "\u125a"-"\u125d",
         "\u1260"-"\u1286",
         "\u1288",
         "\u128a"-"\u128d",
         "\u1290"-"\u12ae",
         "\u12b0",
         "\u12b2"-"\u12b5",
         "\u12b8"-"\u12be",
         "\u12c0",
         "\u12c2"-"\u12c5",
         "\u12c8"-"\u12ce",
         "\u12d0"-"\u12d6",
         "\u12d8"-"\u12ee",
         "\u12f0"-"\u130e",
         "\u1310",
         "\u1312"-"\u1315",
         "\u1318"-"\u131e",
         "\u1320"-"\u1346",
         "\u1348"-"\u135a",
         "\u1369"-"\u1371",
         "\u13a0"-"\u13f4",
         "\u1401"-"\u166c",
         "\u166f"-"\u1676",
         "\u1681"-"\u169a",
         "\u16a0"-"\u16ea",
         "\u16ee"-"\u16f0",
         "\u1700"-"\u170c",
         "\u170e"-"\u1714",
         "\u1720"-"\u1734",
         "\u1740"-"\u1753",
         "\u1760"-"\u176c",
         "\u176e"-"\u1770",
         "\u1772"-"\u1773",
         "\u1780"-"\u17d3",
         "\u17d7",
         "\u17db"-"\u17dd",
         "\u17e0"-"\u17e9",
         "\u180b"-"\u180d",
         "\u1810"-"\u1819",
         "\u1820"-"\u1877",
         "\u1880"-"\u18a9",
         "\u1900"-"\u191c",
         "\u1920"-"\u192b",
         "\u1930"-"\u193b",
         "\u1946"-"\u196d",
         "\u1970"-"\u1974",
         "\u1d00"-"\u1d6b",
         "\u1e00"-"\u1e9b",
         "\u1ea0"-"\u1ef9",
         "\u1f00"-"\u1f15",
         "\u1f18"-"\u1f1d",
         "\u1f20"-"\u1f45",
         "\u1f48"-"\u1f4d",
         "\u1f50"-"\u1f57",
         "\u1f59",
         "\u1f5b",
         "\u1f5d",
         "\u1f5f"-"\u1f7d",
         "\u1f80"-"\u1fb4",
         "\u1fb6"-"\u1fbc",
         "\u1fbe",
         "\u1fc2"-"\u1fc4",
         "\u1fc6"-"\u1fcc",
         "\u1fd0"-"\u1fd3",
         "\u1fd6"-"\u1fdb",
         "\u1fe0"-"\u1fec",
         "\u1ff2"-"\u1ff4",
         "\u1ff6"-"\u1ffc",
         "\u200c"-"\u200f",
         "\u202a"-"\u202e",
         "\u203f"-"\u2040",
         "\u2054",
         "\u2060"-"\u2063",
         "\u206a"-"\u206f",
         "\u2071",
         "\u207f",
         "\u20a0"-"\u20b1",
         "\u20d0"-"\u20dc",
         "\u20e1",
         "\u20e5"-"\u20ea",
         "\u2102",
         "\u2107",
         "\u210a"-"\u2113",
         "\u2115",
         "\u2119"-"\u211d",
         "\u2124",
         "\u2126",
         "\u2128",
         "\u212a"-"\u212d",
         "\u212f"-"\u2131",
         "\u2133"-"\u2139",
         "\u213d"-"\u213f",
         "\u2145"-"\u2149",
         "\u2160"-"\u2183",
         "\u3005"-"\u3007",
         "\u3021"-"\u302f",
         "\u3031"-"\u3035",
         "\u3038"-"\u303c",
         "\u3041"-"\u3096",
         "\u3099"-"\u309a",
         "\u309d"-"\u309f",
         "\u30a1"-"\u30ff",
         "\u3105"-"\u312c",
         "\u3131"-"\u318e",
         "\u31a0"-"\u31b7",
         "\u31f0"-"\u31ff",
         "\u3400"-"\u4db5",
         "\u4e00"-"\u9fa5",
         "\ua000"-"\ua48c",
         "\uac00"-"\ud7a3",
         "\ud801", //for supplementary characters suport
         "\ud802", //for supplementary characters suport
         "\ud834", //for supplementary characters suport
         "\udc00", //for supplementary characters suport
         "\udc01", //for supplementary characters suport
         "\udd7b", //for supplementary characters suport
         "\uf900"-"\ufa2d",
         "\ufa30"-"\ufa6a",
         "\ufb00"-"\ufb06",
         "\ufb13"-"\ufb17",
         "\ufb1d"-"\ufb28",
         "\ufb2a"-"\ufb36",
         "\ufb38"-"\ufb3c",
         "\ufb3e",
         "\ufb40"-"\ufb41",
         "\ufb43"-"\ufb44",
         "\ufb46"-"\ufbb1",
         "\ufbd3"-"\ufd3d",
         "\ufd50"-"\ufd8f",
         "\ufd92"-"\ufdc7",
         "\ufdf0"-"\ufdfc",
         "\ufe00"-"\ufe0f",
         "\ufe20"-"\ufe23",
         "\ufe33"-"\ufe34",
         "\ufe4d"-"\ufe4f",
         "\ufe69",
         "\ufe70"-"\ufe74",
         "\ufe76"-"\ufefc",
         "\ufeff",
         "\uff04",
         "\uff10"-"\uff19",
         "\uff21"-"\uff3a",
         "\uff3f",
         "\uff41"-"\uff5a",
         "\uff65"-"\uffbe",
         "\uffc2"-"\uffc7",
         "\uffca"-"\uffcf",
         "\uffd2"-"\uffd7",
         "\uffda"-"\uffdc",
         "\uffe0"-"\uffe1",
         "\uffe5"-"\uffe6",
         "\ufff9"-"\ufffb"
      ]
  >
}


/*
 * Indentation handling.
 */


<FORCE_NEWLINE1> TOKEN :
{
    <NEWLINE: ("\n" | "\r")>
        {
            matchedToken.kind = NEWLINE;
            matchedToken.image = "<NEWLINE>";
        } : INDENTATION_UNCHANGED
}


<FORCE_NEWLINE2> TOKEN :
{
    <NEWLINE2: ("\n" | "\r")>
        {
            matchedToken.kind = NEWLINE;
            matchedToken.image = "<NEWLINE>";
        } : INDENTING }


<INDENTING, INDENTATION_UNCHANGED> SKIP :
{
    "\t"
        {
            indenting((indent/4+1)*4);
        }
|   " "
        {
            indenting(indent+1);
        }
|   "\014"
        {
            indenting(0);
        }
|   <CRLF1: ("\r\n" | "\n" | "\r")>
        {
            indenting(0);
        }
}


<INDENTATION_UNCHANGED> SKIP :
{
    <"">
        {
            //System.out.println("Keep level [" + level + "]");
        } : DEFAULT
}


<INDENTING> TOKEN :
{
    <DEDENT: "">
        {
            if (indent > indentation[level])
            {
                if (level + 1 >= indentation.length)
                    throw new NullPointerException("too many indentation levels");
                level++;
                indentation[level] = indent;
                matchedToken.kind=INDENT;
                matchedToken.image = "<INDENT>";
                //System.out.println("New level [" + level + "]");
            }
            else
            {
                if (level > 0)
                {
                    Token t = matchedToken;
                    t.image= "<DEDENT>";
                    level -= 1;
                    //System.out.println("Dedent level [" + level + "]");
                    while (level > 0 && indent < indentation[level])
                    {
                        level--;
                        //System.out.println("Dedent level [" + level + "]");
                        // TODO: should clone the original token?
                        t.next = new Token(DEDENT, "<DEDENT>");
                        t = t.next;
                    }
                    if (indent != indentation[level])
                    {
                        throw new NullPointerException("inconsistent dedent at line " +
                            t.endLine + ", column " + t.endColumn);
                    }
                    t.next = null;
                 }
            }

        } : DEFAULT
}

/*
 * Tokens used via code (not in grammar).
 */

<UNREACHABLE> TOKEN :
{
    < INDENT:"<INDENT>">
}


/*
 * Grammar for Beagle programming language
 */


CompilationUnit CompilationUnit():
{
    PackageDeclaration pkg = null;
    List<ImportDeclaration> imports = null;
    ImportDeclaration in = null;
    TypeDeclaration type = null;
    LineInfo linfo = new LineInfo();
}
{
    pkg = PackageDeclaration()
        {
            linfo.updateBegin(pkg);
        }
    ( in = ImportDeclaration()
        {
            linfo.updateBegin(in);
            if (in != null && imports == null)
                imports = new ArrayList<ImportDeclaration>();
            imports.add(in);
        }
    )*
    ( type = TypeDeclaration()
        {
            linfo.update(type);
        }
    )
    /*
     * \u001A is CTRL+Z character
     */
    (<EOF> | "\u001A" )
    {
        return new CompilationUnit(linfo, pkg, imports, type);
    }
}


PackageDeclaration PackageDeclaration():
{
    List<AnnotationExpr> annotations = null;
    AnnotationExpr ann;
    NameExpr name;
    LineInfo linfo = new LineInfo();
    PackageDeclaration pkg;
}
{
    ( ann = Annotation()
        {
            annotations = addAnnotation(annotations, ann);
        }
    )*
    <PACKAGE>
        {
            linfo.updateBegin(token);
        }
    name = Name() <NEWLINE>
        {
            linfo.updateEnd(token);
            return new PackageDeclaration(linfo, annotations, name);
        }
}


ImportDeclaration ImportDeclaration():
{
    NameExpr name;
    boolean isAsterisk = false;
    LineInfo linfo = new LineInfo();
}
{
    <IMPORT>
        {
            linfo.updateBegin(token);
        }
    name = Name()
    [ <DOT> <MUL>
        {
            isAsterisk = true;
        }
    ]
    <NEWLINE>
        {
            linfo.updateEnd(token);
            return new ImportDeclaration(linfo, name, isAsterisk);
        }
}


/*
 * Modifiers. We match all modifiers in a single rule to reduce the chances of
 * syntax errors for simple modifier mistakes. It will also enable us to give
 * better error messages.
 *
 * TODO: separate "access modifiers" from "other modifiers"
 */
ModifierDeclaration Modifiers():
{
    int modifiers = 0;
    AnnotationExpr ann;
    LineInfo linfo = new LineInfo();
}
{
    (
        (
              <FINAL>        { modifiers = ModifierSet.setModifier(modifiers, ModifierSet.FINAL);        linfo.updateBegin(token); }
            | <CONST>        { modifiers = ModifierSet.setModifier(modifiers, ModifierSet.CONST);        linfo.updateBegin(token); }
            | <NATIVE>       { modifiers = ModifierSet.setModifier(modifiers, ModifierSet.NATIVE);       linfo.updateBegin(token); }
            | <PUBLIC>       { modifiers = ModifierSet.setModifier(modifiers, ModifierSet.PUBLIC);       linfo.updateBegin(token); }
            | <STATIC>       { modifiers = ModifierSet.setModifier(modifiers, ModifierSet.STATIC);       linfo.updateBegin(token); }
            | <EXPORT>       { modifiers = ModifierSet.setModifier(modifiers, ModifierSet.EXPORT);       linfo.updateBegin(token); }
            | <PRIVATE>      { modifiers = ModifierSet.setModifier(modifiers, ModifierSet.PRIVATE);      linfo.updateBegin(token); }
            | <READLOCK>     { modifiers = ModifierSet.setModifier(modifiers, ModifierSet.READLOCK);     linfo.updateBegin(token); }
            | <INTERNAL>     { modifiers = ModifierSet.setModifier(modifiers, ModifierSet.INTERNAL);     linfo.updateBegin(token); }
            | <ABSTRACT>     { modifiers = ModifierSet.setModifier(modifiers, ModifierSet.ABSTRACT);     linfo.updateBegin(token); }
            | <PROTECTED>    { modifiers = ModifierSet.setModifier(modifiers, ModifierSet.PROTECTED);    linfo.updateBegin(token); }
            | <WRITELOCK>    { modifiers = ModifierSet.setModifier(modifiers, ModifierSet.WRITELOCK);    linfo.updateBegin(token); }
            | <SYNCHRONIZED> { modifiers = ModifierSet.setModifier(modifiers, ModifierSet.SYNCHRONIZED); linfo.updateBegin(token); }
        )
    )*
        {
            return new ModifierDeclaration(linfo, modifiers);
        }
}


TypeDeclaration TypeDeclaration():
{
   ModifierDeclaration modifier;
   TypeDeclaration typeDecl;
   List<AnnotationExpr> annotations;
}
{
    (
        annotations = AnnotationList()
            /*
             * Store annotations in somewhere!
             */
        modifier = Modifiers()
        (
              typeDecl = ClassOrInterfaceDeclaration(annotations, modifier)
            | typeDecl = EnumDeclaration(annotations, modifier)
            /*| typeDecl = AnnotationTypeDeclaration(annotations, modifier)*/
        )
    )
        {
            return typeDecl;
        }
}


EnumDeclaration EnumDeclaration(List<AnnotationExpr> annotations, ModifierDeclaration modifier):
{
    String name;
    List impList = new LinkedList();
    EnumConstantDeclaration entry;
    List entries = new LinkedList();
    BodyDeclaration member;
    List members = new LinkedList();
    LineInfo linfo = new LineInfo();
}
{
    <ENUM>
        {
            linfo.updateBegin(token);
        }
    <IDENTIFIER>
        {
            name = token.image;
        }
    [ impList = ImplementsList(false) ]
    <COLON>
    <NEWLINE>
    BeginBlock()
    [
        entry = EnumConstantDeclaration()
            {
                entries.add(entry);
            }
        ( LOOKAHEAD(3) <COMMA> [ <NEWLINE> ] entry = EnumConstantDeclaration()
            {
                entries.add(entry);
            }
        )*
    ]
    /*
     * We tolerate an extra comma in the end of the enum constant list due automatic
     * code generation.
     */
    //[ <COMMA> ]
    [
        ( <NEWLINE>
            ( member = ClassOrInterfaceBodyDeclaration(false)
                {
                    members.add(member);
                }
            )*
        )
    ]
    EndBlock()
        {
            linfo.updateEnd(token);
            return new EnumDeclaration(linfo,/*popJavadoc()*/null,
                annotations, modifier, name, impList, entries, members);
        }
}


EnumConstantDeclaration EnumConstantDeclaration():
{
    List annotations = new LinkedList();
    AnnotationExpr ann;
    String name;
    List args = null;
    //List classBody = null;
    LineInfo linfo = new LineInfo();
}
{
    { /*pushJavadoc();*/ }
    annotations = AnnotationList()
    <IDENTIFIER>
        {
            name = token.image;
            linfo.updateBegin(token);
        }
    [ args = Arguments() ]
    //[ classBody = ClassOrInterfaceBody(false) ]
        {
            linfo.updateEnd(token);
            return new EnumConstantDeclaration(linfo,/*popJavadoc()*/null,
                annotations, name, args);
        }
}


List Arguments():
{
    List ret = null;
}
{
    <LPAREN> [ ret = ArgumentList() ] <RPAREN>
        {
            return ret;
        }
}


List ArgumentList():
{
    List ret = new LinkedList();
    Expression expr;
}
{
    expr = Expression()
        {
            ret.add(expr);
        }
    ( <COMMA> expr = Expression()
        {
            ret.add(expr);
        }
    )*
        {
            return ret;
        }
}


ClassOrInterfaceDeclaration ClassOrInterfaceDeclaration(List<AnnotationExpr> annotations, ModifierDeclaration modifier):
{
   boolean isInterface = false;
   String name;
   List typePar = null;
   List extList = null;
   List impList = null;
   List members = null;
   LineInfo linfo = new LineInfo(modifier, null);
}
{
    // Annotations and modifiers matched by caller
    ( <CLASS> | <INTERFACE> { isInterface = true; } )
        {
            linfo.updateBegin(token);
        }
    <IDENTIFIER>
        {
            name = token.image;
        }
    [ extList = ExtendsList(isInterface) ]
    [ impList = ImplementsList(isInterface) ]
    <COLON>
    <NEWLINE>
    members = ClassOrInterfaceBody(isInterface)
        {
            linfo.updateEnd(token);
            return new ClassOrInterfaceDeclaration(linfo,/*popJavadoc()*/null, annotations, modifier,
                isInterface, name, extList, impList, members);
        }
}


List ExtendsList(boolean isInterface):
{
   boolean extendsMoreThanOne = false;
   List ret = new LinkedList();
   ClassOrInterfaceType cit;
}
{
      <EXTENDS> cit = ClassOrInterfaceType()
        {
            ret.add(cit);
        }
    ( <COMMA> cit = ClassOrInterfaceType()
        {
            ret.add(cit);
            extendsMoreThanOne = true;
        }
    )*
        {
            if (extendsMoreThanOne && !isInterface)
                throw new NullPointerException(/*token,*/ "A class cannot extend more than one other class");
            return ret;
        }
}


List ImplementsList(boolean isInterface):
{
   List ret = new LinkedList();
   ClassOrInterfaceType cit;
}
{
    ( <IMPLEMENTS> cit = ClassOrInterfaceType() )
        {
            ret.add(cit);
        }
    ( <COMMA> cit = ClassOrInterfaceType()
        {
            ret.add(cit);
        }
    )*
        {
            if (isInterface)
                throw new NullPointerException(/*token,*/ "An interface cannot implement other interfaces");
            return ret;
        }
}


List ClassOrInterfaceBody(boolean isInterface):
{
    List ret = new LinkedList();
    BodyDeclaration member;
}
{
    BeginBlock()
    ( LOOKAHEAD(2) member = ClassOrInterfaceBodyDeclaration(isInterface)
        {
            ret.add(member);
        }
    )*
    EndBlock()
        {
            return ret;
        }

}


void BeginBlock():
{
}
{
    <INDENT>
}


void EndBlock():
{
}
{
    ( <DEDENT> | <EOF> | "\u001A" )
}


BodyDeclaration ClassOrInterfaceBodyDeclaration(boolean isInterface):
{
   boolean isNestedInterface = false;
   ModifierDeclaration modifier;
   BodyDeclaration ret = null;
   List annotations = null;
}
{
    //{ pushJavadoc(); }
    (
            annotations = AnnotationList()
            modifier = Modifiers() // Just get all the modifiers out of the way. If you want to do
                                   // more checks, pass the modifiers down to the member
            (
                  ret = ClassOrInterfaceDeclaration(annotations, modifier)
                | ret = EnumDeclaration(annotations, modifier)
                | ret = AnnotationTypeDeclaration(annotations, modifier)
                | LOOKAHEAD( <IDENTIFIER> <LPAREN> )
                  ret = ConstructorDeclaration(annotations, modifier)
                | LOOKAHEAD( Type() <IDENTIFIER> ( <COMMA> | <ASSIGN> | <NEWLINE> ) )
                  ret = FieldDeclaration(annotations, modifier)
                | ret = MethodDeclaration(annotations, modifier)
            )
    )
        {
            return ret;
        }
}


ConstructorDeclaration ConstructorDeclaration(List<AnnotationExpr> annotations, ModifierDeclaration modifier):
{
    List typeParameters = null;
    String name;
    List parameters;
    List throws_ = null;
    ExplicitConstructorInvocationStmt exConsInv = null;
    List stmts = new LinkedList();
    LineInfo lctor = new LineInfo();
    LineInfo linfo = new LineInfo();
}
{
    // Annotations and modifiers matched by caller
    <IDENTIFIER>
        {
            name = token.image;
            lctor.updateBegin(token);
        }
    parameters = FormalParameters() <COLON> <NEWLINE>
    BeginBlock()
        {
            linfo.updateBegin(token);
        }

    (
        LOOKAHEAD(ExplicitConstructorInvocation() EndBlock() )
        exConsInv = ExplicitConstructorInvocation()
    |
        LOOKAHEAD(ExplicitConstructorInvocation())
        exConsInv = ExplicitConstructorInvocation()
        stmts = StatementList()
    |
        stmts = StatementList()
    )
    EndBlock()
        {
            if (exConsInv != null)
                stmts.add(0, exConsInv);
            lctor.updateEnd(token);
            linfo.updateEnd(token);
            return new ConstructorDeclaration(lctor,/*popJavadoc()*/null,
                annotations, modifier, name, parameters,
                new BlockStmt(linfo, stmts));
        }
}


ExplicitConstructorInvocationStmt ExplicitConstructorInvocation():
{
    boolean isThis = false;
    List args;
    Expression expr = null;
    List typeArgs = null;
    LineInfo linfo = new LineInfo();
}
{
    (
        LOOKAHEAD( <THIS> <LPAREN> )
        <THIS>
            {
                linfo.updateBegin(token);
                isThis = true;
            }
        args = Arguments() <NEWLINE>
    |
        [
            LOOKAHEAD( PrimaryExpressionWithoutSuperSuffix() <DOT> )
            expr = PrimaryExpressionWithoutSuperSuffix() <DOT>
                {
                    linfo.updateBegin(expr);
                }
        ]
        <SUPER>
            {
                linfo.updateBegin(token);
            }
        args = Arguments() <NEWLINE>
    )
    {
        linfo.updateEnd(token);
        return new ExplicitConstructorInvocationStmt(linfo, isThis, expr, args);
    }
}


FieldDeclaration FieldDeclaration(List<AnnotationExpr> annotations, ModifierDeclaration modifier):
{
    Type type;
    List variables = new LinkedList();
    VariableDeclarator val;
    LineInfo linfo = new LineInfo(modifier, null);
}
{
    // Annotations and modifiers matched by caller
    type = Type()
    val = VariableDeclarator()
        {
            variables.add(val);
        }
    ( <COMMA> val = VariableDeclarator()
        {
            variables.add(val);
        }
    )*
    <NEWLINE>
        {
            linfo.updateBegin(type);
            linfo.updateEnd(token);
            return new FieldDeclaration(linfo, /*popJavadoc()*/null, annotations, modifier, type, variables);
        }
}


/*
 * Unlike Java, Beagle variable/field declarations cannot replace the brackets in type
 * by brackets in the variable/field identifier (e.g. "int a[]" instead "int[] a" )
 */
VariableDeclarator VariableDeclarator():
{
    String name;
    Expression init = null;
    LineInfo linfo = new LineInfo();
}
{
    <IDENTIFIER>
        {
            linfo.updateBegin(token);
            name = token.image;
        }
    [ <ASSIGN> init = VariableInitializer() ]
        {
            if (init != null)
                linfo.updateEnd(init);
            else
                linfo.updateEnd(token);
            return new  VariableDeclarator(linfo, name, init);
        }
}


/*
 * Type, name and expression syntax follows.
 */
Type Type():
{
    Type ret;
}
{
    (
        LOOKAHEAD(2) ret = ReferenceType()
    |
        ret = PrimitiveType()
    )
        {
            return ret;
        }
}


ReferenceType ReferenceType():
{
    Type type;
    int arrayCount = 0;
    LineInfo linfo = new LineInfo();
}
{
    (
        type = PrimitiveType()
        ( LOOKAHEAD(2) <LBRACKET> <RBRACKET>
            {
                arrayCount++;
            }
        )+
    |
        type = ClassOrInterfaceType()
        ( LOOKAHEAD(2) <LBRACKET> <RBRACKET>
            {
                arrayCount++;
            }
        )*
    )
        {
            linfo.update(type);
            return new ReferenceType(linfo, type, arrayCount);
        }
}


/*
 * We don't support generics yet.
 */
ClassOrInterfaceType ClassOrInterfaceType():
{
    ClassOrInterfaceType ret;
}
{
    <IDENTIFIER>
        {
            ret = new ClassOrInterfaceType(new LineInfo(token), null, token.image);
        }
    ( LOOKAHEAD(2) <DOT> <IDENTIFIER>
        {
            ret = new ClassOrInterfaceType(new LineInfo(token), ret, token.image);
        }
    )*
        {
            return ret;
        }
}


PrimitiveType PrimitiveType():
{
    PrimitiveType ret = null;
}
{
    (
          <INT>     { ret = new PrimitiveType(new LineInfo(token), Primitive.Int); }
        | <CHAR>    { ret = new PrimitiveType(new LineInfo(token), Primitive.Char); }
        | <BYTE>    { ret = new PrimitiveType(new LineInfo(token), Primitive.Byte); }
        | <LONG>    { ret = new PrimitiveType(new LineInfo(token), Primitive.Long); }
        | <SHORT>   { ret = new PrimitiveType(new LineInfo(token), Primitive.Short); }
        | <FLOAT>   { ret = new PrimitiveType(new LineInfo(token), Primitive.Float); }
        | <FIXED>   { ret = new PrimitiveType(new LineInfo(token), Primitive.Fixed); }
        | <DOUBLE>  { ret = new PrimitiveType(new LineInfo(token), Primitive.Double); }
        | <BOOLEAN> { ret = new PrimitiveType(new LineInfo(token), Primitive.Boolean); }
    )
        {

            if (ret == null) throw new NullPointerException("Unhandled primitive type");
            return ret;
        }
}


Type ResultType():
{
    Type ret;
}
{
    (
        <VOID>
            {
                ret = new VoidType(new LineInfo(token));
            }
    |
        ret = Type()
    )
        {
            return ret;
        }
}


/*
 * Full qualified names. A lookahead of 2 is required below since "Name" can be followed
 * by a ".*" when used in the context of an "ImportDeclaration".
 */
NameExpr Name():
{
    NameExpr ret;
}
{
    <IDENTIFIER>
        {
            ret = new NameExpr(new LineInfo(token), token.image);
        }
    ( LOOKAHEAD(2) <DOT> <IDENTIFIER>
        {
            LineInfo linfo = new LineInfo();
            linfo.updateBegin(ret);
            linfo.updateEnd(token);
            ret = new QualifiedNameExpr(linfo, ret, token.image);
        }
    )*
    {
        return ret;
    }
}


List NameList():
{
    List ret = new LinkedList();
    NameExpr name;
}
{
    name = Name() { ret.add(name); }
    ( <COMMA> name = Name() { ret.add(name); } )*
        {
            return ret;
        }
}


Expression VariableInitializer():
{
    Expression ret;
}
{
    (
        ret = ArrayInitializer()
    |
        ret = Expression()
    )
        {
            return ret;
        }
}


ArrayInitializerExpr ArrayInitializer():
{
    List values = new ArrayList();
    Expression val;
    LineInfo linfo = new LineInfo();
}
{
    <LBRACKET>
        {
            linfo.updateBegin(token);
        }
    [
        val = VariableInitializer()
            {
                values.add(val);
            }
        ( LOOKAHEAD(2) <COMMA> val = VariableInitializer()
            {
                values.add(val);
            }
        )*
    ]
    /*
     * We tolerate an extra comma in the end of the array initializer due automatic
     * code generation.
     */
    [ <COMMA> ] <RBRACKET>
        {
            linfo.updateEnd(token);
            return new ArrayInitializerExpr(linfo, values);
        }
}


MethodDeclaration MethodDeclaration(List<AnnotationExpr> annotations, ModifierDeclaration modifier):
{
    List typeParameters = null;
    Type type;
    String name;
    List parameters;
    int arrayCount = 0;
    List throws_ = null;
    BlockStmt block = null;
    LineInfo linfo = new LineInfo();
}
{
    // Annotations and modifiers matched by caller
    type = ResultType()
        {
            linfo.updateBegin(type);
        }
    <IDENTIFIER>
        {
            name = token.image;
        }
    parameters = FormalParameters()
    /**
     * Unlike Java, Beagle don't support indicate an array return type using brackets
     * after argument list (e.g. "int values()[]" instead "int[] values()"
     */
    <COLON>
    <NEWLINE>
    block = Block()
        {
            linfo.updateEnd(token);
            return new MethodDeclaration(linfo, /*popJavadoc()*/null,
                annotations, modifier, type, name, parameters, block);
        }
}


List FormalParameters():
{
    List ret = new ArrayList();
    Parameter par;
}
{
    <LPAREN>
    [ par = FormalParameter()
        {
            ret.add(par);
        }
        ( <COMMA> par = FormalParameter()
            {
                ret.add(par);
            }
        )*
    ]
    <RPAREN>
        {
            return ret;
        }
}


Parameter FormalParameter():
{
    ModifierDeclaration modifier;
    Type type;
    boolean isVarArg = false;
    String name;
    LineInfo linfo = new LineInfo();
}
{
    modifier = Modifiers()
        {
            linfo.updateBegin(modifier);
        }
    type = Type()
    [ <VARARG>
        {
            isVarArg = true;
        }
    ]
    <IDENTIFIER>
        {
            linfo.updateEnd(token);
            name = token.image;
            return new Parameter(linfo, modifier, type, isVarArg, name);
        }
}


BlockStmt Block():
{
    List stmts = new ArrayList();
    LineInfo linfo = new LineInfo();
}
{
    BeginBlock()
        {
            linfo.update(token);
        }
    stmts = StatementList()
    EndBlock()
        {
            return new BlockStmt(linfo, stmts);
        }
}


List StatementList():
{
    List ret = new LinkedList();
    Statement stmt;
}
{
    ( stmt = GenericStatement()
        {
            ret.add(stmt);
        }
    )+
        {
            return ret;
        }
}


Statement GenericStatement():
{
    Statement ret;
    Expression expr;
    ClassOrInterfaceDeclaration typeDecl;
    ModifierDeclaration modifier;
    LineInfo linfo = new LineInfo();
}
{
    (
        LOOKAHEAD(VariableDeclarationExpression() )
        expr = VariableDeclarationExpression() <NEWLINE>
            {
                linfo.updateBegin(expr);
                linfo.updateEnd(token);
                ret = new ExpressionStmt(linfo, expr);
            }
    |
        ret = Statement()
    )
        {
            return ret;
        }
}


/*
 * Statement syntax follows.
 */

Statement Statement():
{
    Statement ret;
}
{
    (
        //LOOKAHEAD(2)
        ret = AssertStatement()
    |
        ret = EmptyStatement()
    |
        ret = StatementExpression()
    |
        ret = SwitchStatement()
    |
        ret = IfStatement()
    |
        ret = WhileStatement()
    |
        ret = DoWhileStatement()
    |
        ret = ForStatement()
    |
        ret = BreakStatement()
    |
        ret = ContinueStatement()
    |
        ret = ReturnStatement()
    |
        ret = ThrowStatement()
    |
        ret = SynchronizedStatement()
    |
        ret = TryStatement()
    )
        {
            return ret;
        }
}


AssertStmt AssertStatement():
{
    Expression check;
    Expression msg = null;
    LineInfo linfo = new LineInfo();
}
{
    <ASSERT>
        {
            linfo.updateBegin(token);
        }
    check = Expression() [ <COLON> msg = Expression() ] <NEWLINE>
        {
            linfo.updateEnd(token);
            return new AssertStmt(linfo, check, msg);
        }
}


VariableDeclarationExpr VariableDeclarationExpression():
{
    ModifierDeclaration modifier;
    Type type;
    List vars = new LinkedList();
    VariableDeclarator var;
    List annotations;
    LineInfo linfo = new LineInfo();
}
{
    annotations = AnnotationList()
    modifier = Modifiers()
        {
            linfo.updateBegin(modifier);
        }
    type = Type()
    var = VariableDeclarator()
        {
            vars.add(var);
        }
    ( <COMMA> var = VariableDeclarator()
        {
            vars.add(var);
        }
    )*
        {
            linfo.updateEnd(token);
            return new VariableDeclarationExpr(linfo, annotations, modifier, type, vars);
        }
}


EmptyStmt EmptyStatement():
{
}
{
    <PASS> <NEWLINE>
        {
            return new EmptyStmt(new LineInfo(token));
        }
}

ExpressionStmt StatementExpression():
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.  This expansion does not
 * use PostfixExpression for performance reasons.
 */

{
    Expression expr;
    AssignOperator op;
    Expression value;
}
{
    (
        expr = PreIncrementExpression()
    |
        expr = PreDecrementExpression()
    |
        expr = PrimaryExpression()
        [
            <INCR>
                {
                    expr = new UnaryExpr(new LineInfo(expr, token), expr, UnaryOperator.POST_INCREMENT);
                }
        |
            <DECR>
                {
                    expr = new UnaryExpr(new LineInfo(expr, token), expr, UnaryOperator.POST_DECREMENT);
                }
        |
            op = AssignmentOperator() value = Expression()
                {
                    expr = new AssignExpr(new LineInfo(expr, token), expr, value, op);
                }
        ]
    )
    <NEWLINE>
        {
            return new ExpressionStmt(new LineInfo(expr, token), expr);
        }
}


SwitchStmt SwitchStatement():
{
    Expression selector;
    SwitchEntryStmt entry;
    List entries = new LinkedList();
    LineInfo linfo = new LineInfo();
}
{
    <SWITCH>
        {
            linfo.updateBegin(token);
        }
    <LPAREN> selector = Expression() <RPAREN> <COLON> <NEWLINE>
    BeginBlock()
    ( entry = SwitchEntry()
        {
            entries.add(entry);
        }
    )*
    EndBlock()
        {
            linfo.updateEnd(token);
            return new SwitchStmt(linfo, selector, entries);
        }
}


SwitchEntryStmt SwitchEntry():
{
    Expression label = null;
    List stmts;
    LineInfo linfo = new LineInfo();
}
{
    (
        <CASE>
            {
                linfo.updateBegin(token);
            }
        label = Expression()
    |
        <_DEFAULT>
            {
                linfo.updateBegin(token);
            }
    )
    <COLON> <NEWLINE>
    BeginBlock()
    stmts = StatementList()
    EndBlock()
        {
            linfo.updateEnd(token);
            return new SwitchEntryStmt(linfo, label, stmts);
        }
}


IfStmt IfStatement():
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{
    Expression condition;
    Statement thenStmt;
    Statement elseStmt = null;
    LineInfo linfo = new LineInfo();
}
{
    <IF>
        {
            linfo.updateBegin(token);
        }
    <LPAREN> condition = Expression() <RPAREN> <COLON> <NEWLINE>
    thenStmt = Block()
    (
        <ELIF> <LPAREN> Expression() <RPAREN> <COLON> <NEWLINE>
        Block()
            {
                // include the elif statements
            }
    )*
    [ <ELSE> <COLON> <NEWLINE> elseStmt = Block() ]
        {
            linfo.updateEnd(token);
            return new IfStmt(linfo, condition, thenStmt, elseStmt);
        }
}


WhileStmt WhileStatement():
{
    Expression condition;
    Statement body;
    LineInfo linfo = new LineInfo();
}
{
    <WHILE>
        {
            linfo.updateBegin(token);
        }
    <LPAREN> condition = Expression() <RPAREN> <COLON> <NEWLINE>
    body = Block()
        {
            linfo.updateEnd(token);
            return new WhileStmt(linfo, condition, body);
        }
}


DoWhileStmt DoWhileStatement():
{
    Expression condition;
    Statement body;
    LineInfo linfo = new LineInfo();
}
{
    <DO> <WHILE>
        {
            linfo.updateBegin(token);
        }
    <LPAREN> condition = Expression() <RPAREN> <COLON> <NEWLINE>
    body = Block()
        {
            linfo.updateEnd(token);
            return new DoWhileStmt(linfo, body, condition);
        }
}


Statement ForStatement():
{
    String id = null;
    VariableDeclarationExpr varExpr = null;
    Expression expr = null;
    List init = null;
    List update = null;
    Statement body;
    LineInfo linfo = new LineInfo();
}
{
    <FOR>
        {
            linfo.updateBegin(token);
        }
    <LPAREN>
    (
        LOOKAHEAD(VariableDeclarationExpression() <IN> )
        varExpr = VariableDeclarationExpression() <IN> expr = Expression()
    |
        [ init = ForInit() ] <SEMICOLON> [ expr = Expression() ] <SEMICOLON> [ update = ForUpdate() ]
    )
    <RPAREN> <COLON> <NEWLINE> body = Block()
        {
            linfo.updateEnd(token);
            if (varExpr != null)
                return new ForeachStmt(linfo, varExpr, expr, body);
            else
                return new ForStmt(linfo, init, expr, update, body);
        }
}


List ForInit():
{
    List ret;
    Expression expr;
}
{
    (
        LOOKAHEAD( Modifiers() Type() <IDENTIFIER> )
        expr = VariableDeclarationExpression()
            {
                ret = new LinkedList(); ret.add(expr);
            }
    |
        ret = ExpressionList()
    )
        {
            return ret;
        }
}


List ExpressionList():
{
    List ret = new LinkedList();
    Expression expr;
}
{
    expr = Expression()
        {
            ret.add(expr);
        }
    ( <COMMA> expr = Expression()
        {
            ret.add(expr);
        }
    )*
        {
            return ret;
        }
}


List ForUpdate():
{
    List ret;
}
{
    ret = ExpressionList()
        {
            return ret;
        }
}


BreakStmt BreakStatement():
{
    String id = null;
    LineInfo linfo = new LineInfo();
}
{
    <BREAK>
        {
            linfo.updateBegin(token);
        }
    <NEWLINE>
        {
            linfo.updateEnd(token);
            return new BreakStmt(linfo);
        }
}


ContinueStmt ContinueStatement():
{
    String id = null;
    LineInfo linfo = new LineInfo();
}
{
    <CONTINUE>
        {
            linfo.updateBegin(token);
        }
    <NEWLINE>
        {
            linfo.updateEnd(token);
            return new ContinueStmt(linfo);
        }
}


ReturnStmt ReturnStatement():
{
    Expression expr = null;
    LineInfo linfo = new LineInfo();
}
{
    <RETURN>
        {
            linfo.updateBegin(token);
        }
    [ expr = Expression() ] <NEWLINE>
        {
            linfo.updateEnd(token);
            return new ReturnStmt(linfo, expr);
        }
}


ThrowStmt ThrowStatement():
{
    Expression expr;
    LineInfo linfo = new LineInfo();
}
{
    <THROW>
        {
            linfo.updateBegin(token);
        }
    expr = Expression() <NEWLINE>
        {
            linfo.updateEnd(token);
            return new ThrowStmt(linfo, expr);
        }
}


SynchronizedStmt SynchronizedStatement():
{
    Expression expr;
    BlockStmt block;
    LineInfo linfo = new LineInfo();
}
{
    <SYNCHRONIZED>
        {
            linfo.updateBegin(token);
        }
    <LPAREN> expr = Expression() <RPAREN> <COLON> <NEWLINE>
    block = Block()
        {
            linfo.updateEnd(token);
            return new SynchronizedStmt(linfo, expr, block);
        }
}


TryStmt TryStatement():
/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */
{
    BlockStmt tryBlock;
    BlockStmt finallyBlock = null;
    List<CatchClause> catchs = new LinkedList<CatchClause>();
    Parameter except;
    BlockStmt catchBlock;
    LineInfo linfo = new LineInfo();
    LineInfo cinfo = null;
}
{
    <TRY> <COLON> <NEWLINE>
        {
            linfo.updateBegin(token);
        }
    tryBlock = Block()
    (
        (
            <CATCH>
                {
                    cinfo = new LineInfo(token, null);
                }
            <LPAREN> except = FormalParameter() <RPAREN> <COLON> <NEWLINE>
            catchBlock = Block()
                {
                    cinfo.updateEnd(token);
                    catchs.add( new CatchClause(cinfo, except, catchBlock) );
                }
        )+
        [ <FINALLY> <COLON> <NEWLINE> finallyBlock = Block() ]
    |
        <FINALLY> <COLON> <NEWLINE> finallyBlock = Block()
    )
    {
        linfo.updateEnd(token);
        return new TryStmt(linfo, tryBlock, catchs, finallyBlock);
    }
}


/*
 * Annotation syntax.
 */


List AnnotationList():
{
    List<AnnotationExpr> annotations = new LinkedList<AnnotationExpr>();
    AnnotationExpr ann;
}
{
    ( LOOKAHEAD(2) ann = Annotation()
        {
            annotations.add(ann);
        }
    )*
        {
            return annotations;
        }
}


AnnotationExpr Annotation():
{
    AnnotationExpr ret;
}
{
    (
        LOOKAHEAD( <AT> Name() <LPAREN> ( <IDENTIFIER> <ASSIGN> | <RPAREN> ))
        ret = NormalAnnotation()
    |
        LOOKAHEAD( <AT> Name() <LPAREN> )
        ret = SingleMemberAnnotation()
    |
        ret = MarkerAnnotation()
    )
        {
            return ret;
        }
}

NormalAnnotationExpr NormalAnnotation():
{
    NameExpr name;
    List pairs = null;
    LineInfo linfo = new LineInfo();
}
{
    <AT>
        {
            linfo.updateBegin(token);
        }
    name = Name() <LPAREN>
    [ pairs = MemberValuePairs() ]
    <RPAREN> <NEWLINE>
        {
            linfo.updateEnd(token);
            return new NormalAnnotationExpr(linfo, name, pairs);
        }
}


MarkerAnnotationExpr MarkerAnnotation():
{
    NameExpr name;
    LineInfo linfo = new LineInfo();
}
{
    <AT>
        {
            linfo.updateBegin(token);
        }
    name = Name() <NEWLINE>
        {
            linfo.updateEnd(token);
            return new MarkerAnnotationExpr(linfo, name);
        }
}


SingleMemberAnnotationExpr SingleMemberAnnotation():
{
    NameExpr name;
    Expression memberVal;
    LineInfo linfo = new LineInfo();
}
{
    <AT>
        {
            linfo.updateBegin(token);
        }
    name = Name() <LPAREN> memberVal = MemberValue() <RPAREN> <NEWLINE>
        {
            linfo.updateEnd(token);
            return new SingleMemberAnnotationExpr(linfo, name, memberVal);
        }
}


List MemberValuePairs():
{
    List ret = new LinkedList();
    MemberValuePair pair;
}
{
    pair = MemberValuePair()
        {
            ret.add(pair);
        }
    ( <COMMA> pair = MemberValuePair()
        {
            ret.add(pair);
        }
    )*
        {
            return ret;
        }
}


MemberValuePair MemberValuePair():
{
    String name;
    Expression value;
    LineInfo linfo = new LineInfo();
}
{
    <IDENTIFIER>
        {
            name = token.image;
            linfo.updateBegin(token);
        }
    <ASSIGN> value = MemberValue()
        {
            linfo.updateEnd(token);
            return new MemberValuePair(linfo, name, value);
        }
}


Expression MemberValue():
{
    Expression ret;
}
{
    (
        ret = Annotation()
    |
        ret = MemberValueArrayInitializer()
    |
        ret = ConditionalExpression()
    )
        {
            return ret;
        }
}


Expression  MemberValueArrayInitializer():
{
    List ret = new LinkedList();
    Expression member;
    LineInfo linfo = new LineInfo();
}
{
    <LBRACKET>
        {
            linfo.updateBegin(token);
        }
    ( member = MemberValue()
        {
            ret.add(member);
        }
        ( LOOKAHEAD(2) <COMMA> member = MemberValue()
            {
                ret.add(member);
            }
        )*
    )?
    [ <COMMA> ] <RBRACKET>
        {
            linfo.updateEnd(token);
            return new ArrayInitializerExpr(linfo, ret);
        }
}


/* Annotation Types. */

AnnotationDeclaration AnnotationTypeDeclaration(List<AnnotationExpr> annotations, ModifierDeclaration modifier):
{
    String name;
    List members;
    LineInfo linfo = new LineInfo();
}
{
    <AT>
        {
            linfo.updateBegin(token);
        }
    <INTERFACE> <IDENTIFIER>
        {
        name = token.image;
        }
    members = AnnotationTypeBody()
        {
            linfo.updateEnd(token);
            return new AnnotationDeclaration(linfo,/*popJavadoc()*/null,
                annotations, modifier, name, members);
        }
}


List AnnotationTypeBody():
{
    List ret = new LinkedList();
    BodyDeclaration member;
}
{
    BeginBlock()
    (
        member = AnnotationBodyDeclaration()
            {
                ret.add(member);
            }
    )*
    EndBlock()
        {
            return ret;
        }
}


BodyDeclaration AnnotationBodyDeclaration():
{
   ModifierDeclaration modifier;
   List<AnnotationExpr> annotations;
   BodyDeclaration ret;
   LineInfo linfo = new LineInfo();
}
{
    { /*pushJavadoc();*/ }
    (
       <NEWLINE>
            {
                linfo.update(token);
                ret = new EmptyTypeDeclaration(linfo, /*popJavadoc()*/null);
            }
    |
        annotations = AnnotationList()
        modifier = Modifiers()
        (
            LOOKAHEAD(Type() <IDENTIFIER> <LPAREN>)
            ret = AnnotationTypeMemberDeclaration(annotations, modifier)
        |
            ret = ClassOrInterfaceDeclaration(annotations, modifier)
        |
            ret = EnumDeclaration(annotations, modifier)
        |
            ret = AnnotationTypeDeclaration(annotations, modifier)
        |
            ret = FieldDeclaration(annotations, modifier)
        )
    )
        {
            return ret;
        }
}


AnnotationMemberDeclaration AnnotationTypeMemberDeclaration(List<AnnotationExpr> annotations, ModifierDeclaration modifier):
{
    Type type;
    String name;
    Expression defaultVal = null;
    LineInfo linfo = new LineInfo(modifier, null);
}
{
    type = Type() <IDENTIFIER>
        {
            name = token.image;
        }
    <LPAREN> <RPAREN> [ defaultVal = DefaultValue() ] <NEWLINE>
        {
            linfo.update(token);
            return new AnnotationMemberDeclaration(linfo, /*popJavadoc()*/null, annotations, modifier, type, name, defaultVal);
        }
}


Expression DefaultValue():
{
    Expression ret;
}
{
    <_DEFAULT> ret = MemberValue()
        {
            return ret;
        }
}


/*
 * Expression syntax follows.
 */

Expression Expression():
/*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */
{
    Expression ret;
    AssignOperator op;
    Expression value;
}
{
    ret = ConditionalExpression()
    [
        LOOKAHEAD(2)
        op = AssignmentOperator() value = Expression()
            {
                ret = new AssignExpr(new LineInfo(ret, token), ret, value, op);
            }
    ]
        {
            return ret;
        }
}


AssignOperator AssignmentOperator():
{
    AssignOperator ret;
}
{
    (
            <ASSIGN>
                {
                    ret = AssignOperator.ASSIGN;
                }
        |
            <ASN_MUL>
                {
                    ret = AssignOperator.ASN_MUL;
                }
        |
            <ASN_DIV>
                {
                    ret = AssignOperator.ASN_DIV;
                }
        |
            <ASN_REM>
                {
                    ret = AssignOperator.ASN_REM;
                }
        |
            <ASN_ADD>
                {
                    ret = AssignOperator.ASN_ADD;
                }
        |
            <ASN_SUB>
                {
                    ret = AssignOperator.ASN_SUB;
                }
        |
            <ASN_SHL>
                {
                    ret = AssignOperator.ASN_SHL;
                }
        |
            <ASN_SHR>
                {
                    ret = AssignOperator.ASN_SHR;
                }
        |
            <ASN_BAND>
                {
                    ret = AssignOperator.ASN_BAND;
                }
        |
            <ASN_XOR>
                {
                    ret = AssignOperator.ASN_XOR;
                }
        |
            <ASN_BOR>
                {
                    ret = AssignOperator.ASN_BOR;
                }
    )
    {
        return ret;
    }
}


Expression ConditionalExpression():
{
    Expression ret;
    Expression left;
    Expression right;
}
{
    ret = ConditionalOrExpression()
    [ <HOOK> left = Expression() <COLON> right = ConditionalExpression()
        {
            ret = new ConditionalExpr(new LineInfo(ret, token), ret, left, right);
        }
    ]
        {
            return ret;
        }
}


Expression ConditionalOrExpression():
{
    Expression ret;
    Expression right;
}
{
    ret = ConditionalAndExpression()
    ( <LOR> right = ConditionalAndExpression()
        {
            ret = new BinaryExpr(new LineInfo(ret, token), ret, right, BinaryOperator.LOR);
        }
    )*
        {
            return ret;
        }
}


Expression ConditionalAndExpression():
{
    Expression ret;
    Expression right;
}
{
    ret = InclusiveOrExpression()
    ( <LAND> right = InclusiveOrExpression()
        {
            ret = new BinaryExpr(new LineInfo(ret, token), ret, right, BinaryOperator.LAND);
        }
    )*
        {
            return ret;
        }
}


Expression InclusiveOrExpression():
{
    Expression ret;
    Expression right;
}
{
    ret = ExclusiveOrExpression()
    ( <BOR> right = ExclusiveOrExpression()
        {
            ret = new BinaryExpr(new LineInfo(ret, token), ret, right, BinaryOperator.BOR);
        }
    )*
        {
            return ret;
        }
}


Expression ExclusiveOrExpression():
{
    Expression ret;
    Expression right;
}
{
    ret = AndExpression()
    ( <XOR> right = AndExpression()
        {
            ret = new BinaryExpr(new LineInfo(ret, token), ret, right, BinaryOperator.XOR);
        }
    )*
        {
            return ret;
        }
}


Expression AndExpression():
{
    Expression ret;
    Expression right;
}
{
    ret = EqualityExpression()
    ( <BAND> right = EqualityExpression()
        {
            ret = new BinaryExpr(new LineInfo(ret, token), ret, right, BinaryOperator.BAND);
        }
    )*
        {
            return ret;
        }
}


Expression EqualityExpression():
{
    Expression ret;
    Expression right;
    BinaryOperator op;
}
{
    ret = InstanceOfExpression()
    (
        (
            <EQ>
                {
                    op = BinaryOperator.EQ;
                }
        |
            <NE>
                {
                    op = BinaryOperator.NE;
                }
        )
        right = InstanceOfExpression()
            {
                ret = new BinaryExpr(new LineInfo(ret, token), ret, right, op);
            }
    )*
        {
            return ret;
        }
}


Expression InstanceOfExpression():
{
    Expression ret;
    Type type;
}
{
    ret = RelationalExpression()
    [ <INSTANCEOF> type = Type()
        {
            ret = new InstanceOfExpr(new LineInfo(ret, token), ret, type);
        }
    ]
        {
            return ret;
        }
}


Expression RelationalExpression():
{
    Expression ret;
    Expression right;
    BinaryOperator op;
}
{
    ret = ShiftExpression()
    (
        (
            <LT>
                {
                    op = BinaryOperator.LT;
                }
        |
            <GT>
                {
                    op = BinaryOperator.GT;
                }
        |
            <LE>
                {
                    op = BinaryOperator.LE;
                }
        |
            <GE>
                {
                    op = BinaryOperator.GE;
                }
        )
        right = ShiftExpression()
            {
                ret = new BinaryExpr(new LineInfo(ret, token), ret, right, op);
            }
    )*
        {
            return ret;
        }
}

Expression ShiftExpression():
{
    Expression ret;
    Expression right;
    BinaryOperator op;
}
{
    ret = AdditiveExpression()
    (
        (
            <SHL>
                {
                    op = BinaryOperator.SHL;
                }
        |
            <SHR>
                {
                    op = BinaryOperator.SHR;
                }
        )
        right = AdditiveExpression()
            {
                ret = new BinaryExpr(new LineInfo(ret, token), ret, right, op);
            }
    )*
        {
            return ret;
        }
}


Expression AdditiveExpression():
{
    Expression ret;
    Expression right;
    BinaryOperator op;
}
{
    ret = MultiplicativeExpression()
    (
        (
            <ADD>
                {
                    op = BinaryOperator.ADD;
                }
        |
            <SUB>
                {
                    op = BinaryOperator.SUB;
                }
        )
        right = MultiplicativeExpression()
            {
               ret = new BinaryExpr(new LineInfo(ret, token), ret, right, op);
            }
    )*
        {
            return ret;
        }
}


Expression MultiplicativeExpression():
{
    Expression ret;
    Expression right;
    BinaryOperator op;
}
{
    ret = UnaryExpression()
    (
        (
            <MUL>
                {
                    op = BinaryOperator.MUL;
                }
        |
            <DIV>
                {
                    op = BinaryOperator.DIV;
                }
        |
            <REM>
                {
                    op = BinaryOperator.REM;
                }
        )
        right = UnaryExpression()
            {
                ret = new BinaryExpr(new LineInfo(ret, token), ret, right, op);
            }
    )*
        {
            return ret;
        }
}


Expression UnaryExpression():
{
    Expression ret;
    UnaryOperator op;
    LineInfo linfo = new LineInfo();
}
{
    (
        ret = PreIncrementExpression()
    |
        ret = PreDecrementExpression()
    |
        (
            <ADD>
                {
                    op = UnaryOperator.PLUS;
                    linfo.updateBegin(token);
                }
        |
            <SUB>
                {
                    op = UnaryOperator.MINUS;
                    linfo.updateBegin(token);
                }
        )
        ret = UnaryExpression()
            {
                if (op == UnaryOperator.MINUS)
                {
                    linfo.updateEnd(token);
                    ret = new UnaryExpr(linfo, ret, op);
                }
                else
                {
                    linfo.updateEnd(token);
                    ret = new UnaryExpr(linfo, ret, op);
                }
            }
    |
        ret = UnaryExpressionNotPlusMinus()
    )
        {
            return ret;
        }
}


Expression PreIncrementExpression():
{
    Expression ret;
    LineInfo linfo = new LineInfo();
}
{
    <INCR>
        {
            linfo.updateBegin(token);
        }
    ret = UnaryExpression()
        {
            linfo.updateEnd(token);
            return new UnaryExpr(linfo, ret, UnaryOperator.PRE_INCREMENT);
        }
}


Expression PreDecrementExpression():
{
    Expression ret;
    LineInfo linfo = new LineInfo();
}
{
    <DECR>
        {
            linfo.updateBegin(token);
        }
    ret = UnaryExpression()
        {
            linfo.updateEnd(token);
            ret = new UnaryExpr(linfo, ret, UnaryOperator.PRE_DECREMENT);
        }
        {
            return ret;
        }
}


Expression UnaryExpressionNotPlusMinus():
{
    Expression ret;
    UnaryOperator op;
    LineInfo linfo = new LineInfo();
}
{
    (
        (
            <BNEG>
                {
                    op = UnaryOperator.BNEG;
                    linfo.updateBegin(token);
                }
        |
            <LNEG>
                {
                    op = UnaryOperator.LNEG;
                    linfo.updateBegin(token);
                }
        )
        ret = UnaryExpression()
            {
                linfo.updateEnd(token);
                ret = new UnaryExpr(linfo, ret, op);
            }
    |
        LOOKAHEAD( CastExpression() )
        ret = CastExpression()
    |
        ret = PostfixExpression()
    )
        {
            return ret;
        }
}


Expression PostfixExpression():
{
    Expression ret;
    UnaryOperator op;
}
{
    ret = PrimaryExpression()
    [
        LOOKAHEAD(2)
            (
                <INCR>
                    {
                        op = UnaryOperator.POST_INCREMENT;
                    }
            |
                <DECR>
                    {
                        op = UnaryOperator.POST_DECREMENT;
                    }
            )
                {
                    ret = new UnaryExpr(new LineInfo(ret, token), ret, op);
                }
    ]
        {
            return ret;
        }
}


Expression CastExpression():
{
    Expression ret;
    Type type;
    LineInfo linfo = new LineInfo();
}
{
    <LPAREN>
        {
            linfo.updateBegin(token);
        }
    (
        LOOKAHEAD(2)
        type = PrimitiveType() <RPAREN> ret = UnaryExpression()
            {
                linfo.updateEnd(token);
                ret = new CastExpr(linfo, type, ret);
            }
    |
        type = ReferenceType() <RPAREN> ret = UnaryExpressionNotPlusMinus()
            {
                linfo.updateEnd(token);
                ret = new CastExpr(linfo, type, ret);
            }
    )
        {
            return ret;
        }
}


Expression PrimaryExpression():
{
    Expression ret;
    Expression inner;
}
{
    ret = PrimaryPrefix()
    (
        LOOKAHEAD(2) ret = PrimarySuffix(ret)
    )*
        {
            return ret;
        }
}


Expression PrimaryExpressionWithoutSuperSuffix():
{
    Expression ret;
    Expression inner;
}
{
    ret = PrimaryPrefix()
    (
        LOOKAHEAD( PrimarySuffixWithoutSuper(null) )
        ret = PrimarySuffixWithoutSuper(ret)
    )*
        {
            return ret;
        }
}


Expression PrimaryPrefix():
{
    Expression ret;
    String name;
    List typeArgs = null;
    List args = null;
    boolean hasArgs = false;
    Type type;
    LineInfo linfo;
}
{
    (
        ret = Literal()
    |
        <THIS>
            {
                ret = new ThisExpr(new LineInfo(token), null);
            }
    |
        <SUPER>
            {
                ret = new SuperExpr(new LineInfo(token), null);
            }
        <DOT>
        <IDENTIFIER>
            {
                name = token.image;
            }
        [ args = Arguments()
            {
                hasArgs=true;
            }
        ]
            {
            if (hasArgs)
                ret = new MethodCallExpr(new LineInfo(ret, token), ret, name, args);
            else
                ret = new FieldAccessExpr(new LineInfo(ret, token), ret, name);
            }
    |
        <LPAREN>
            {
                linfo = new LineInfo(token, null);
            }
        ret = Expression() <RPAREN>
            {
                linfo.updateEnd(token);
                ret = new EnclosedExpr(linfo, ret);
            }
    |
        ret = AllocationExpression(null)
    |
        LOOKAHEAD( ResultType() <DOT> <CLASS> )
        type = ResultType() <DOT> <CLASS>
            {
                ret = new ClassExpr(new LineInfo(type, token), type);
            }
    |
        <IDENTIFIER>
            {
                name = token.image;
                linfo = new LineInfo(token, null);
            }
        [ args = Arguments()
            {
                hasArgs=true;
            }
        ]
            {
                linfo.updateEnd(token);
                if (hasArgs)
                    ret =  new MethodCallExpr(linfo, null, name, args);
                else
                    ret =  new NameExpr(linfo, name);
            }
    )
    {
        return ret;
    }
}


Expression PrimarySuffix(Expression scope):
{
    Expression ret;
}
{
    (
        LOOKAHEAD(2)
        ret = PrimarySuffixWithoutSuper(scope)
    |
        <DOT> <SUPER>
            {
                ret = new SuperExpr(new LineInfo(scope, token), scope);
            }
    )
        {
            return ret;
        }
}


Expression PrimarySuffixWithoutSuper(Expression scope):
{
    Expression ret;
    List args = null;
    boolean hasArgs = false;
    String name;
}
{
    (
        <DOT>
        (
            <THIS>
                {
                    ret = new ThisExpr(new LineInfo(scope, token), scope);
                }
        |
            ret = AllocationExpression(scope)
        |
            LOOKAHEAD( <IDENTIFIER> )
            <IDENTIFIER>
                {
                    name = token.image;
                }
            [ args = Arguments()
                {
                    hasArgs=true;
                }
            ]
            {
                if (hasArgs)
                    ret = new MethodCallExpr(new LineInfo(scope, token), scope, name, args);
                else
                    ret = new FieldAccessExpr(new LineInfo(scope, token), scope, name);
            }
        )
    |
        <LBRACKET> ret = Expression() <RBRACKET>
            {
                ret = new ArrayAccessExpr(new LineInfo(scope, token), scope, ret);
            }
    )
        {
            return ret;
        }
}


Expression Literal():
{
    Expression ret;
}
{
    (
        <INTEGER_LITERAL>
            {
                ret = new IntegerLiteralExpr(new LineInfo(token), token.image);
            }
    |
        <LONG_LITERAL>
            {
                ret = new LongLiteralExpr(new LineInfo(token), token.image);
            }
    |
        <FLOATING_POINT_LITERAL>
            {
                ret = new DoubleLiteralExpr(new LineInfo(token), token.image);
            }
    |
        <CHARACTER_LITERAL>
            {
                ret = new CharLiteralExpr(new LineInfo(token), token.image.substring(1, token.image.length()-1));
            }
    |
        <STRING_LITERAL>
            {
                ret = new StringLiteralExpr(new LineInfo(token), token.image.substring(1, token.image.length()-1));
            }
    |
        ret = BooleanLiteral()
    |
        ret = NullLiteral()
    )
        {
            return ret;
        }
}


Expression BooleanLiteral():
{
    Expression ret;
}
{
    (
        <TRUE>
            {
                ret = new BooleanLiteralExpr(new LineInfo(token), true);
            }
    |
        <FALSE>
            {
                ret = new BooleanLiteralExpr(new LineInfo(token), false);
            }
    )
        {
            return ret;
        }
}


Expression NullLiteral():
{
}
{
    <NULL>
    {
        return new NullLiteralExpr(new LineInfo(token));
    }
}


Expression AllocationExpression(Expression scope):
{
    Expression ret;
    Type type;
    Object[] arr = null;
    List args;
    LineInfo linfo = new LineInfo();
}
{
    <NEW>
        {
            if (scope == null)
                linfo.updateBegin(token);
            else
                linfo.updateBegin(scope);
        }
    (
        type = PrimitiveType()
        arr = ArrayDimsAndInits()
        {
            linfo.updateEnd(token);
            if (arr[0] instanceof Integer)
            {
                ret = new ArrayCreationExpr(linfo, type, ((Integer)arr[0]).intValue(), (ArrayInitializerExpr)arr[1]);
            }
            else
            {
                ret = new ArrayCreationExpr(linfo, type, (List)arr[0], ((Integer)arr[1]).intValue());
            }
        }
    |
        LOOKAHEAD(ClassOrInterfaceType() ArrayDimsAndInits())
        type = ClassOrInterfaceType()
        arr = ArrayDimsAndInits()
            {
                linfo.updateEnd(token);
                if (arr[0] instanceof Integer)
                {
                    ret = new ArrayCreationExpr(linfo, type, ((Integer)arr[0]).intValue(), (ArrayInitializerExpr)arr[1]);
                }
                else
                {
                    ret = new ArrayCreationExpr(linfo, type, (List)arr[0], ((Integer)arr[1]).intValue());
                }
            }
    |
        type = ClassOrInterfaceType()
        args = Arguments()
            {
                linfo.updateEnd(token);
                ret = new ObjectCreationExpr(linfo, scope, (ClassOrInterfaceType) type, args);
            }
    )
        {
            return ret;
        }
}


/*
 * The third LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[" and "]".
 */
/*
 * Match with something like "[][] = [ [1, 2], [3, 4]" where the numbers can be any expression.
 */
Object[] ArrayDimsAndInits():
{
    Object[] ret = new Object[2];
    Expression expr;
    List inits = new LinkedList();
    int i = 0;
}
{
    (
        LOOKAHEAD(2)
        ( LOOKAHEAD(2) <LBRACKET> expr = Expression()
            {
                inits.add(expr);
            }
        <RBRACKET> )+
        ( LOOKAHEAD(2) <LBRACKET> <RBRACKET>
            {
            i++;
            }
        )*
            {
                ret[0] = inits;
                ret[1] = new Integer(i);
            }
    |
        ( LOOKAHEAD(2) <LBRACKET> <RBRACKET>
            {
                i++;
            }
        )+
        expr = ArrayInitializer()
            {
                ret[0] = new Integer(i);
                ret[1] = expr;
            }
    )
        {
            return ret;
        }
}
